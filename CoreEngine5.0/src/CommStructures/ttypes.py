#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None



class StreamFileDetails:
  """
  Stream File Details
  (1) serverId - Stream file located server/group.
  (2) from - Begin timestamp of this video/image (ddMMyyyyHHmmss format).
  (3) to - End timestamp of this video/image (ddMMyyyyHHmmss format).
  (4) fileSize - The size of this video/image. uint: B.
  (5) url - The url/path of the video/image.
  (6) createdTime - The time media file created, on KUP it is the upload time.
  (7) progress - The video/image upload progress, units : percent, from "0" to "100".
  (8) status - The upload status. Valid values are:
              "uploading" means video/image is being uploaded.
              "completed" means video/image upload completed.
              "retrying" means upload error, but Core is retrying again.
              "aborted" means upload error, and Core gives up the uploading.
                        In this case, Platform need call "requestStreamForPlayback"
                        to trigger upload again.

  Attributes:
   - serverId
   - from
   - to
   - fileSize
   - url
   - createdTime
   - progress
   - status
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'serverId', None, None, ), # 1
    (2, TType.STRING, 'from', None, None, ), # 2
    (3, TType.STRING, 'to', None, None, ), # 3
    (4, TType.STRING, 'fileSize', None, None, ), # 4
    (5, TType.STRING, 'url', None, None, ), # 5
    (6, TType.STRING, 'createdTime', None, None, ), # 6
    (7, TType.STRING, 'progress', None, None, ), # 7
    (8, TType.STRING, 'status', None, None, ), # 8
  )

  def __init__(self, serverId=None, froms=None, to=None, fileSize=None, url=None, createdTime=None, progress=None, status=None,):
    self.serverId = serverId
    self.froms = froms
    self.to = to
    self.fileSize = fileSize
    self.url = url
    self.createdTime = createdTime
    self.progress = progress
    self.status = status

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.serverId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.froms = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.to = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.fileSize = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.createdTime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.progress = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.status = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamFileDetails')
    if self.serverId is not None:
      oprot.writeFieldBegin('serverId', TType.STRING, 1)
      oprot.writeString(self.serverId)
      oprot.writeFieldEnd()
    if self.froms is not None:
      oprot.writeFieldBegin('from', TType.STRING, 2)
      oprot.writeString(self.froms)
      oprot.writeFieldEnd()
    if self.to is not None:
      oprot.writeFieldBegin('to', TType.STRING, 3)
      oprot.writeString(self.to)
      oprot.writeFieldEnd()
    if self.fileSize is not None:
      oprot.writeFieldBegin('fileSize', TType.STRING, 4)
      oprot.writeString(self.fileSize)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 5)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.createdTime is not None:
      oprot.writeFieldBegin('createdTime', TType.STRING, 6)
      oprot.writeString(self.createdTime)
      oprot.writeFieldEnd()
    if self.progress is not None:
      oprot.writeFieldBegin('progress', TType.STRING, 7)
      oprot.writeString(self.progress)
      oprot.writeFieldEnd()
    if self.status is not None:
      oprot.writeFieldBegin('status', TType.STRING, 8)
      oprot.writeString(self.status)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StreamClientInfo:
  """
  Stream Client Info
  (1) clientIp - IP address of the client connected to this stream
  (2) clientPort - Port number of the client connected to this stream

  Attributes:
   - clientIp
   - clientPort
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'clientIp', None, None, ), # 1
    (2, TType.STRING, 'clientPort', None, None, ), # 2
  )

  def __init__(self, clientIp=None, clientPort=None,):
    self.clientIp = clientIp
    self.clientPort = clientPort

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.clientIp = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.clientPort = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamClientInfo')
    if self.clientIp is not None:
      oprot.writeFieldBegin('clientIp', TType.STRING, 1)
      oprot.writeString(self.clientIp)
      oprot.writeFieldEnd()
    if self.clientPort is not None:
      oprot.writeFieldBegin('clientPort', TType.STRING, 2)
      oprot.writeString(self.clientPort)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StreamInfo:
  """
  Stream Information
  (1) deviceId - The device ID
  (2) channelId - The channel ID
  (3) isLiveview - Indicates liveview or playback
  (4) type - The stream type, e.g. "http/jpeg" or "rtmp/h264"
  (5) url - The stream URL as visible to outside world
  (6) startTime - The timestamp when stream was started (ddMMyyyyHHmmss format)
  (7) clients - List of clients connected to this stream

  Attributes:
   - deviceId
   - channelId
   - isLiveview
   - type
   - url
   - startTime
   - clients
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'deviceId', None, None, ), # 1
    (2, TType.STRING, 'channelId', None, None, ), # 2
    (3, TType.BOOL, 'isLiveview', None, None, ), # 3
    (4, TType.STRING, 'type', None, None, ), # 4
    (5, TType.STRING, 'url', None, None, ), # 5
    (6, TType.STRING, 'startTime', None, None, ), # 6
    (7, TType.LIST, 'clients', (TType.STRUCT,(StreamClientInfo, StreamClientInfo.thrift_spec)), None, ), # 7
  )

  def __init__(self, deviceId=None, channelId=None, isLiveview=None, type=None, url=None, startTime=None, clients=None,):
    self.deviceId = deviceId
    self.channelId = channelId
    self.isLiveview = isLiveview
    self.type = type
    self.url = url
    self.startTime = startTime
    self.clients = clients

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.deviceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.channelId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isLiveview = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.startTime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.LIST:
          self.clients = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = StreamClientInfo()
            _elem5.read(iprot)
            self.clients.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamInfo')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.STRING, 1)
      oprot.writeString(self.deviceId)
      oprot.writeFieldEnd()
    if self.channelId is not None:
      oprot.writeFieldBegin('channelId', TType.STRING, 2)
      oprot.writeString(self.channelId)
      oprot.writeFieldEnd()
    if self.isLiveview is not None:
      oprot.writeFieldBegin('isLiveview', TType.BOOL, 3)
      oprot.writeBool(self.isLiveview)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.STRING, 4)
      oprot.writeString(self.type)
      oprot.writeFieldEnd()
    if self.url is not None:
      oprot.writeFieldBegin('url', TType.STRING, 5)
      oprot.writeString(self.url)
      oprot.writeFieldEnd()
    if self.startTime is not None:
      oprot.writeFieldBegin('startTime', TType.STRING, 6)
      oprot.writeString(self.startTime)
      oprot.writeFieldEnd()
    if self.clients is not None:
      oprot.writeFieldBegin('clients', TType.LIST, 7)
      oprot.writeListBegin(TType.STRUCT, len(self.clients))
      for iter6 in self.clients:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class StorageInfo:
  """
  Recording Server Storage Status
  (1) serverId - The recording server ID
  (2) serverHost - The recording server host
  (3) streamCount - The number of streams that server is processing
  (4) freeSpace - The available disk space in this server. uint: MB
  (5) totalSpace - The total disk space in this server. uint: MB

  Attributes:
   - serverId
   - serverHost
   - streamCount
   - freeSpace
   - totalSpace
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'serverId', None, None, ), # 1
    (2, TType.STRING, 'serverHost', None, None, ), # 2
    (3, TType.I64, 'streamCount', None, None, ), # 3
    (4, TType.I64, 'freeSpace', None, None, ), # 4
    (5, TType.I64, 'totalSpace', None, None, ), # 5
  )

  def __init__(self, serverId=None, serverHost=None, streamCount=None, freeSpace=None, totalSpace=None,):
    self.serverId = serverId
    self.serverHost = serverHost
    self.streamCount = streamCount
    self.freeSpace = freeSpace
    self.totalSpace = totalSpace

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.serverId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.serverHost = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.streamCount = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.freeSpace = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.totalSpace = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StorageInfo')
    if self.serverId is not None:
      oprot.writeFieldBegin('serverId', TType.STRING, 1)
      oprot.writeString(self.serverId)
      oprot.writeFieldEnd()
    if self.serverHost is not None:
      oprot.writeFieldBegin('serverHost', TType.STRING, 2)
      oprot.writeString(self.serverHost)
      oprot.writeFieldEnd()
    if self.streamCount is not None:
      oprot.writeFieldBegin('streamCount', TType.I64, 3)
      oprot.writeI64(self.streamCount)
      oprot.writeFieldEnd()
    if self.freeSpace is not None:
      oprot.writeFieldBegin('freeSpace', TType.I64, 4)
      oprot.writeI64(self.freeSpace)
      oprot.writeFieldEnd()
    if self.totalSpace is not None:
      oprot.writeFieldBegin('totalSpace', TType.I64, 5)
      oprot.writeI64(self.totalSpace)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
