#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Iface:
  """
  Recording Server communication interface.
  """
  def getServerID(self, ):
    """
    Get the id of this recording server.
    """
    pass

  def setGlobalConfiguration(self, configurations):
    """
    Set global recording configurations.
    (1) configurations - Detailed global configurations for recording server, example of the json string:
                        {"chunk-size":15,"reserved-space":5120,"cloud-server":"core.up.uat.kaisquare.com"}
                        fields specification:
                        "chunk-size" - the duration of each video recorded, unit: minute
                        "reserved-space" - reserved disk space for storage, unit: MB
                        "cloud-server" - cloud server where the videoes synchronize, or set to "localhost" not to synchronize
                        flexible for future extension
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - configurations
    """
    pass

  def setDeviceConfiguration(self, deviceId, channel, configurations):
    """
    Set device recording configurations.
    (1) deviceId - Device ID.
    (2) channel - The requested channel index.
    (3) configurations - Detailed device configurations, example of the json string:
                         {"stream-storage-limit":20480,"keep-days":7}
                         fields specification:
                         "stream-storage-limit" - max disk space occupied by one channel, unit: MB
                         "keep-days" - the days recording server keep the videoes
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - configurations
    """
    pass

  def setDeviceSnapshot(self, deviceId, channel, snapshot):
    """
    Set device snapshot for recording.
    (1) deviceId - Device ID.
    (2) channel - Device channel.
    (3) snapshot - Snapshot buffer.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - snapshot
    """
    pass

  def startRecordingTask(self, deviceId, channel, mediaType, streamProfile):
    """
    Starts a recording task for recording server.
    (1) deviceId - Device ID.
    (2) channel - The requested channel.
    (3) mediaType - Recording media type, can be "video"/"audio"/"image".
    (4) streamProfile - Detailed device stream related parameters.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - streamProfile
    """
    pass

  def stopRecordingTask(self, deviceId, channel, mediaType):
    """
    Stops a recording task for recording server.
    The recorded media files will be kept in case started again in future.
    (1) deviceId - Device ID.
    (2) channel - The requested channel.
    (3) mediaType - Recording media type, can be "video"/"audio"/"image".
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
    """
    pass

  def terminateRecordingTask(self, deviceId):
    """
    Terminates a recording task for recording server.
    The recorded media files will be removed.
    (1) deviceId - Device ID.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
    """
    pass

  def getRecordingDetails(self, deviceId, channel, deviceKey, mediaType, beginTime, endTime):
    """
    Get recording details of the stream files.
    (1) deviceId - Device ID.
    (2) channel - The requested channel.
    (3) deviceKey - The unique device key.
    (4) mediaType - Recording media type, can be "video"/"audio"/"image".
    (5) beginTime - Begin time.
    (6) endTime - End time.
    RETURN a structure of StreamFileDetails.

    Parameters:
     - deviceId
     - channel
     - deviceKey
     - mediaType
     - beginTime
     - endTime
    """
    pass

  def triggerEventRecording(self, deviceId, channel, mediaType, eventId, duration):
    """
    Trigger an event recording.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) eventId - Unique string to identify an event.
    (5) duration - Duration of this event, unit: second.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - eventId
     - duration
    """
    pass

  def getEventRecording(self, deviceId, channel, mediaType, eventId):
    """
    Get an event recording.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) eventId - Unique string to identify an event.
    RETURN the path of the event file.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - eventId
    """
    pass

  def triggerSpecifiedRecording(self, deviceId, channel, mediaType, beginTime, endTime):
    """
    Trigger a time specified recording, generate one video according to the begin and end time.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio".
    (4) beginTime - Begin time.
    (5) endTime - End time.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - beginTime
     - endTime
    """
    pass

  def getSpecifiedRecording(self, deviceId, channel, mediaType, beginTime, endTime):
    """
    Get a time specified recording.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio".
    (4) beginTime - Begin time.
    (5) endTime - End time.
    RETURN the path of the recording file.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - beginTime
     - endTime
    """
    pass

  def startRecordingUpload(self, deviceId, channel, mediaType, beginTime, endTime):
    """
    Trigger recording server to upload media files to KUP.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) beginTime - Begin time.
    (5) endTime - End time.
    RETURN file begin time list.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - beginTime
     - endTime
    """
    pass

  def stopRecordingUpload(self, deviceId, channel, mediaType, fileTime):
    """
    Trigger recording server to stop uploading media files to KUP.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) fileTime - File begin time list.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - fileTime
    """
    pass

  def getStreamStatus(self, streamFileDetails):
    """
    Get the stream's uploading status.

    (1) streamFileDetails - Please refer to CommStructures.StreamFileDetails

    Returns list of stream file status.

    Parameters:
     - streamFileDetails
    """
    pass

  def removeMediaFile(self, deviceId, channel, mediaType, mediaInfo):
    """
    Remove a media file from recording server.
    (1) deviceId - Device ID.
    (2) channel - Device channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) mediaInfo - Additional details associated with the remove action, example of the json string:
                   {"mac":"d0:27:88:e7:70:ad","time":"20141127140012","group":"groupX"}
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - mediaInfo
    """
    pass

  def getStorageStatus(self, ):
    """
    Returns list of recording server storage status.
    """
    pass

  def getRecordingServerReport(self, deviceId):
    """
    Get recording server report for diagnosis.
    (1) deviceId - Device ID.
    If deviceId is 0, return the general report,
    else return the device specified report.
    RETURN json formatted recording server report.

    Parameters:
     - deviceId
    """
    pass


class Client(Iface):
  """
  Recording Server communication interface.
  """
  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot is not None:
      self._oprot = oprot
    self._seqid = 0

  def getServerID(self, ):
    """
    Get the id of this recording server.
    """
    self.send_getServerID()
    return self.recv_getServerID()

  def send_getServerID(self, ):
    self._oprot.writeMessageBegin('getServerID', TMessageType.CALL, self._seqid)
    args = getServerID_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getServerID(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getServerID_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getServerID failed: unknown result");

  def setGlobalConfiguration(self, configurations):
    """
    Set global recording configurations.
    (1) configurations - Detailed global configurations for recording server, example of the json string:
                        {"chunk-size":15,"reserved-space":5120,"cloud-server":"core.up.uat.kaisquare.com"}
                        fields specification:
                        "chunk-size" - the duration of each video recorded, unit: minute
                        "reserved-space" - reserved disk space for storage, unit: MB
                        "cloud-server" - cloud server where the videoes synchronize, or set to "localhost" not to synchronize
                        flexible for future extension
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - configurations
    """
    self.send_setGlobalConfiguration(configurations)
    return self.recv_setGlobalConfiguration()

  def send_setGlobalConfiguration(self, configurations):
    self._oprot.writeMessageBegin('setGlobalConfiguration', TMessageType.CALL, self._seqid)
    args = setGlobalConfiguration_args()
    args.configurations = configurations
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setGlobalConfiguration(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setGlobalConfiguration_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setGlobalConfiguration failed: unknown result");

  def setDeviceConfiguration(self, deviceId, channel, configurations):
    """
    Set device recording configurations.
    (1) deviceId - Device ID.
    (2) channel - The requested channel index.
    (3) configurations - Detailed device configurations, example of the json string:
                         {"stream-storage-limit":20480,"keep-days":7}
                         fields specification:
                         "stream-storage-limit" - max disk space occupied by one channel, unit: MB
                         "keep-days" - the days recording server keep the videoes
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - configurations
    """
    self.send_setDeviceConfiguration(deviceId, channel, configurations)
    return self.recv_setDeviceConfiguration()

  def send_setDeviceConfiguration(self, deviceId, channel, configurations):
    self._oprot.writeMessageBegin('setDeviceConfiguration', TMessageType.CALL, self._seqid)
    args = setDeviceConfiguration_args()
    args.deviceId = deviceId
    args.channel = channel
    args.configurations = configurations
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setDeviceConfiguration(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setDeviceConfiguration_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setDeviceConfiguration failed: unknown result");

  def setDeviceSnapshot(self, deviceId, channel, snapshot):
    """
    Set device snapshot for recording.
    (1) deviceId - Device ID.
    (2) channel - Device channel.
    (3) snapshot - Snapshot buffer.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - snapshot
    """
    self.send_setDeviceSnapshot(deviceId, channel, snapshot)
    return self.recv_setDeviceSnapshot()

  def send_setDeviceSnapshot(self, deviceId, channel, snapshot):
    self._oprot.writeMessageBegin('setDeviceSnapshot', TMessageType.CALL, self._seqid)
    args = setDeviceSnapshot_args()
    args.deviceId = deviceId
    args.channel = channel
    args.snapshot = snapshot
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_setDeviceSnapshot(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = setDeviceSnapshot_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "setDeviceSnapshot failed: unknown result");

  def startRecordingTask(self, deviceId, channel, mediaType, streamProfile):
    """
    Starts a recording task for recording server.
    (1) deviceId - Device ID.
    (2) channel - The requested channel.
    (3) mediaType - Recording media type, can be "video"/"audio"/"image".
    (4) streamProfile - Detailed device stream related parameters.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - streamProfile
    """
    self.send_startRecordingTask(deviceId, channel, mediaType, streamProfile)
    return self.recv_startRecordingTask()

  def send_startRecordingTask(self, deviceId, channel, mediaType, streamProfile):
    self._oprot.writeMessageBegin('startRecordingTask', TMessageType.CALL, self._seqid)
    args = startRecordingTask_args()
    args.deviceId = deviceId
    args.channel = channel
    args.mediaType = mediaType
    args.streamProfile = streamProfile
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startRecordingTask(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startRecordingTask_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startRecordingTask failed: unknown result");

  def stopRecordingTask(self, deviceId, channel, mediaType):
    """
    Stops a recording task for recording server.
    The recorded media files will be kept in case started again in future.
    (1) deviceId - Device ID.
    (2) channel - The requested channel.
    (3) mediaType - Recording media type, can be "video"/"audio"/"image".
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
    """
    self.send_stopRecordingTask(deviceId, channel, mediaType)
    return self.recv_stopRecordingTask()

  def send_stopRecordingTask(self, deviceId, channel, mediaType):
    self._oprot.writeMessageBegin('stopRecordingTask', TMessageType.CALL, self._seqid)
    args = stopRecordingTask_args()
    args.deviceId = deviceId
    args.channel = channel
    args.mediaType = mediaType
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopRecordingTask(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stopRecordingTask_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "stopRecordingTask failed: unknown result");

  def terminateRecordingTask(self, deviceId):
    """
    Terminates a recording task for recording server.
    The recorded media files will be removed.
    (1) deviceId - Device ID.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
    """
    self.send_terminateRecordingTask(deviceId)
    return self.recv_terminateRecordingTask()

  def send_terminateRecordingTask(self, deviceId):
    self._oprot.writeMessageBegin('terminateRecordingTask', TMessageType.CALL, self._seqid)
    args = terminateRecordingTask_args()
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_terminateRecordingTask(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = terminateRecordingTask_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "terminateRecordingTask failed: unknown result");

  def getRecordingDetails(self, deviceId, channel, deviceKey, mediaType, beginTime, endTime):
    """
    Get recording details of the stream files.
    (1) deviceId - Device ID.
    (2) channel - The requested channel.
    (3) deviceKey - The unique device key.
    (4) mediaType - Recording media type, can be "video"/"audio"/"image".
    (5) beginTime - Begin time.
    (6) endTime - End time.
    RETURN a structure of StreamFileDetails.

    Parameters:
     - deviceId
     - channel
     - deviceKey
     - mediaType
     - beginTime
     - endTime
    """
    self.send_getRecordingDetails(deviceId, channel, deviceKey, mediaType, beginTime, endTime)
    return self.recv_getRecordingDetails()

  def send_getRecordingDetails(self, deviceId, channel, deviceKey, mediaType, beginTime, endTime):
    self._oprot.writeMessageBegin('getRecordingDetails', TMessageType.CALL, self._seqid)
    args = getRecordingDetails_args()
    args.deviceId = deviceId
    args.channel = channel
    args.deviceKey = deviceKey
    args.mediaType = mediaType
    args.beginTime = beginTime
    args.endTime = endTime
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRecordingDetails(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRecordingDetails_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRecordingDetails failed: unknown result");

  def triggerEventRecording(self, deviceId, channel, mediaType, eventId, duration):
    """
    Trigger an event recording.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) eventId - Unique string to identify an event.
    (5) duration - Duration of this event, unit: second.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - eventId
     - duration
    """
    self.send_triggerEventRecording(deviceId, channel, mediaType, eventId, duration)
    return self.recv_triggerEventRecording()

  def send_triggerEventRecording(self, deviceId, channel, mediaType, eventId, duration):
    self._oprot.writeMessageBegin('triggerEventRecording', TMessageType.CALL, self._seqid)
    args = triggerEventRecording_args()
    args.deviceId = deviceId
    args.channel = channel
    args.mediaType = mediaType
    args.eventId = eventId
    args.duration = duration
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_triggerEventRecording(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = triggerEventRecording_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "triggerEventRecording failed: unknown result");

  def getEventRecording(self, deviceId, channel, mediaType, eventId):
    """
    Get an event recording.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) eventId - Unique string to identify an event.
    RETURN the path of the event file.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - eventId
    """
    self.send_getEventRecording(deviceId, channel, mediaType, eventId)
    return self.recv_getEventRecording()

  def send_getEventRecording(self, deviceId, channel, mediaType, eventId):
    self._oprot.writeMessageBegin('getEventRecording', TMessageType.CALL, self._seqid)
    args = getEventRecording_args()
    args.deviceId = deviceId
    args.channel = channel
    args.mediaType = mediaType
    args.eventId = eventId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getEventRecording(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getEventRecording_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getEventRecording failed: unknown result");

  def triggerSpecifiedRecording(self, deviceId, channel, mediaType, beginTime, endTime):
    """
    Trigger a time specified recording, generate one video according to the begin and end time.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio".
    (4) beginTime - Begin time.
    (5) endTime - End time.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - beginTime
     - endTime
    """
    self.send_triggerSpecifiedRecording(deviceId, channel, mediaType, beginTime, endTime)
    return self.recv_triggerSpecifiedRecording()

  def send_triggerSpecifiedRecording(self, deviceId, channel, mediaType, beginTime, endTime):
    self._oprot.writeMessageBegin('triggerSpecifiedRecording', TMessageType.CALL, self._seqid)
    args = triggerSpecifiedRecording_args()
    args.deviceId = deviceId
    args.channel = channel
    args.mediaType = mediaType
    args.beginTime = beginTime
    args.endTime = endTime
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_triggerSpecifiedRecording(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = triggerSpecifiedRecording_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "triggerSpecifiedRecording failed: unknown result");

  def getSpecifiedRecording(self, deviceId, channel, mediaType, beginTime, endTime):
    """
    Get a time specified recording.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio".
    (4) beginTime - Begin time.
    (5) endTime - End time.
    RETURN the path of the recording file.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - beginTime
     - endTime
    """
    self.send_getSpecifiedRecording(deviceId, channel, mediaType, beginTime, endTime)
    return self.recv_getSpecifiedRecording()

  def send_getSpecifiedRecording(self, deviceId, channel, mediaType, beginTime, endTime):
    self._oprot.writeMessageBegin('getSpecifiedRecording', TMessageType.CALL, self._seqid)
    args = getSpecifiedRecording_args()
    args.deviceId = deviceId
    args.channel = channel
    args.mediaType = mediaType
    args.beginTime = beginTime
    args.endTime = endTime
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getSpecifiedRecording(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getSpecifiedRecording_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getSpecifiedRecording failed: unknown result");

  def startRecordingUpload(self, deviceId, channel, mediaType, beginTime, endTime):
    """
    Trigger recording server to upload media files to KUP.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) beginTime - Begin time.
    (5) endTime - End time.
    RETURN file begin time list.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - beginTime
     - endTime
    """
    self.send_startRecordingUpload(deviceId, channel, mediaType, beginTime, endTime)
    return self.recv_startRecordingUpload()

  def send_startRecordingUpload(self, deviceId, channel, mediaType, beginTime, endTime):
    self._oprot.writeMessageBegin('startRecordingUpload', TMessageType.CALL, self._seqid)
    args = startRecordingUpload_args()
    args.deviceId = deviceId
    args.channel = channel
    args.mediaType = mediaType
    args.beginTime = beginTime
    args.endTime = endTime
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_startRecordingUpload(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = startRecordingUpload_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "startRecordingUpload failed: unknown result");

  def stopRecordingUpload(self, deviceId, channel, mediaType, fileTime):
    """
    Trigger recording server to stop uploading media files to KUP.
    (1) deviceId - Device ID.
    (2) channel - Channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) fileTime - File begin time list.
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - fileTime
    """
    self.send_stopRecordingUpload(deviceId, channel, mediaType, fileTime)
    return self.recv_stopRecordingUpload()

  def send_stopRecordingUpload(self, deviceId, channel, mediaType, fileTime):
    self._oprot.writeMessageBegin('stopRecordingUpload', TMessageType.CALL, self._seqid)
    args = stopRecordingUpload_args()
    args.deviceId = deviceId
    args.channel = channel
    args.mediaType = mediaType
    args.fileTime = fileTime
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_stopRecordingUpload(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = stopRecordingUpload_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "stopRecordingUpload failed: unknown result");

  def getStreamStatus(self, streamFileDetails):
    """
    Get the stream's uploading status.

    (1) streamFileDetails - Please refer to CommStructures.StreamFileDetails

    Returns list of stream file status.

    Parameters:
     - streamFileDetails
    """
    self.send_getStreamStatus(streamFileDetails)
    return self.recv_getStreamStatus()

  def send_getStreamStatus(self, streamFileDetails):
    self._oprot.writeMessageBegin('getStreamStatus', TMessageType.CALL, self._seqid)
    args = getStreamStatus_args()
    args.streamFileDetails = streamFileDetails
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getStreamStatus(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getStreamStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getStreamStatus failed: unknown result");

  def removeMediaFile(self, deviceId, channel, mediaType, mediaInfo):
    """
    Remove a media file from recording server.
    (1) deviceId - Device ID.
    (2) channel - Device channel.
    (3) mediaType - Media type, can be "video"/"audio"/"image".
    (4) mediaInfo - Additional details associated with the remove action, example of the json string:
                   {"mac":"d0:27:88:e7:70:ad","time":"20141127140012","group":"groupX"}
    RETURN true if the operation succeed, false if fail.

    Parameters:
     - deviceId
     - channel
     - mediaType
     - mediaInfo
    """
    self.send_removeMediaFile(deviceId, channel, mediaType, mediaInfo)
    return self.recv_removeMediaFile()

  def send_removeMediaFile(self, deviceId, channel, mediaType, mediaInfo):
    self._oprot.writeMessageBegin('removeMediaFile', TMessageType.CALL, self._seqid)
    args = removeMediaFile_args()
    args.deviceId = deviceId
    args.channel = channel
    args.mediaType = mediaType
    args.mediaInfo = mediaInfo
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_removeMediaFile(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = removeMediaFile_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "removeMediaFile failed: unknown result");

  def getStorageStatus(self, ):
    """
    Returns list of recording server storage status.
    """
    self.send_getStorageStatus()
    return self.recv_getStorageStatus()

  def send_getStorageStatus(self, ):
    self._oprot.writeMessageBegin('getStorageStatus', TMessageType.CALL, self._seqid)
    args = getStorageStatus_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getStorageStatus(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getStorageStatus_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getStorageStatus failed: unknown result");

  def getRecordingServerReport(self, deviceId):
    """
    Get recording server report for diagnosis.
    (1) deviceId - Device ID.
    If deviceId is 0, return the general report,
    else return the device specified report.
    RETURN json formatted recording server report.

    Parameters:
     - deviceId
    """
    self.send_getRecordingServerReport(deviceId)
    return self.recv_getRecordingServerReport()

  def send_getRecordingServerReport(self, deviceId):
    self._oprot.writeMessageBegin('getRecordingServerReport', TMessageType.CALL, self._seqid)
    args = getRecordingServerReport_args()
    args.deviceId = deviceId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRecordingServerReport(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRecordingServerReport_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRecordingServerReport failed: unknown result");


class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["getServerID"] = Processor.process_getServerID
    self._processMap["setGlobalConfiguration"] = Processor.process_setGlobalConfiguration
    self._processMap["setDeviceConfiguration"] = Processor.process_setDeviceConfiguration
    self._processMap["setDeviceSnapshot"] = Processor.process_setDeviceSnapshot
    self._processMap["startRecordingTask"] = Processor.process_startRecordingTask
    self._processMap["stopRecordingTask"] = Processor.process_stopRecordingTask
    self._processMap["terminateRecordingTask"] = Processor.process_terminateRecordingTask
    self._processMap["getRecordingDetails"] = Processor.process_getRecordingDetails
    self._processMap["triggerEventRecording"] = Processor.process_triggerEventRecording
    self._processMap["getEventRecording"] = Processor.process_getEventRecording
    self._processMap["triggerSpecifiedRecording"] = Processor.process_triggerSpecifiedRecording
    self._processMap["getSpecifiedRecording"] = Processor.process_getSpecifiedRecording
    self._processMap["startRecordingUpload"] = Processor.process_startRecordingUpload
    self._processMap["stopRecordingUpload"] = Processor.process_stopRecordingUpload
    self._processMap["getStreamStatus"] = Processor.process_getStreamStatus
    self._processMap["removeMediaFile"] = Processor.process_removeMediaFile
    self._processMap["getStorageStatus"] = Processor.process_getStorageStatus
    self._processMap["getRecordingServerReport"] = Processor.process_getRecordingServerReport

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      self._processMap[name](self, seqid, iprot, oprot)
    return True

  def process_getServerID(self, seqid, iprot, oprot):
    args = getServerID_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getServerID_result()
    result.success = self._handler.getServerID()
    oprot.writeMessageBegin("getServerID", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setGlobalConfiguration(self, seqid, iprot, oprot):
    args = setGlobalConfiguration_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setGlobalConfiguration_result()
    result.success = self._handler.setGlobalConfiguration(args.configurations)
    oprot.writeMessageBegin("setGlobalConfiguration", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setDeviceConfiguration(self, seqid, iprot, oprot):
    args = setDeviceConfiguration_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setDeviceConfiguration_result()
    result.success = self._handler.setDeviceConfiguration(args.deviceId, args.channel, args.configurations)
    oprot.writeMessageBegin("setDeviceConfiguration", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_setDeviceSnapshot(self, seqid, iprot, oprot):
    args = setDeviceSnapshot_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = setDeviceSnapshot_result()
    result.success = self._handler.setDeviceSnapshot(args.deviceId, args.channel, args.snapshot)
    oprot.writeMessageBegin("setDeviceSnapshot", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startRecordingTask(self, seqid, iprot, oprot):
    args = startRecordingTask_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startRecordingTask_result()
    result.success = self._handler.startRecordingTask(args.deviceId, args.channel, args.mediaType, args.streamProfile)
    oprot.writeMessageBegin("startRecordingTask", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopRecordingTask(self, seqid, iprot, oprot):
    args = stopRecordingTask_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopRecordingTask_result()
    result.success = self._handler.stopRecordingTask(args.deviceId, args.channel, args.mediaType)
    oprot.writeMessageBegin("stopRecordingTask", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_terminateRecordingTask(self, seqid, iprot, oprot):
    args = terminateRecordingTask_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = terminateRecordingTask_result()
    result.success = self._handler.terminateRecordingTask(args.deviceId)
    oprot.writeMessageBegin("terminateRecordingTask", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRecordingDetails(self, seqid, iprot, oprot):
    args = getRecordingDetails_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRecordingDetails_result()
    result.success = self._handler.getRecordingDetails(args.deviceId, args.channel, args.deviceKey, args.mediaType, args.beginTime, args.endTime)
    oprot.writeMessageBegin("getRecordingDetails", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_triggerEventRecording(self, seqid, iprot, oprot):
    args = triggerEventRecording_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = triggerEventRecording_result()
    result.success = self._handler.triggerEventRecording(args.deviceId, args.channel, args.mediaType, args.eventId, args.duration)
    oprot.writeMessageBegin("triggerEventRecording", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getEventRecording(self, seqid, iprot, oprot):
    args = getEventRecording_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getEventRecording_result()
    result.success = self._handler.getEventRecording(args.deviceId, args.channel, args.mediaType, args.eventId)
    oprot.writeMessageBegin("getEventRecording", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_triggerSpecifiedRecording(self, seqid, iprot, oprot):
    args = triggerSpecifiedRecording_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = triggerSpecifiedRecording_result()
    result.success = self._handler.triggerSpecifiedRecording(args.deviceId, args.channel, args.mediaType, args.beginTime, args.endTime)
    oprot.writeMessageBegin("triggerSpecifiedRecording", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getSpecifiedRecording(self, seqid, iprot, oprot):
    args = getSpecifiedRecording_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getSpecifiedRecording_result()
    result.success = self._handler.getSpecifiedRecording(args.deviceId, args.channel, args.mediaType, args.beginTime, args.endTime)
    oprot.writeMessageBegin("getSpecifiedRecording", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_startRecordingUpload(self, seqid, iprot, oprot):
    args = startRecordingUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = startRecordingUpload_result()
    result.success = self._handler.startRecordingUpload(args.deviceId, args.channel, args.mediaType, args.beginTime, args.endTime)
    oprot.writeMessageBegin("startRecordingUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_stopRecordingUpload(self, seqid, iprot, oprot):
    args = stopRecordingUpload_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = stopRecordingUpload_result()
    result.success = self._handler.stopRecordingUpload(args.deviceId, args.channel, args.mediaType, args.fileTime)
    oprot.writeMessageBegin("stopRecordingUpload", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getStreamStatus(self, seqid, iprot, oprot):
    args = getStreamStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getStreamStatus_result()
    result.success = self._handler.getStreamStatus(args.streamFileDetails)
    oprot.writeMessageBegin("getStreamStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_removeMediaFile(self, seqid, iprot, oprot):
    args = removeMediaFile_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = removeMediaFile_result()
    result.success = self._handler.removeMediaFile(args.deviceId, args.channel, args.mediaType, args.mediaInfo)
    oprot.writeMessageBegin("removeMediaFile", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getStorageStatus(self, seqid, iprot, oprot):
    args = getStorageStatus_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getStorageStatus_result()
    result.success = self._handler.getStorageStatus()
    oprot.writeMessageBegin("getStorageStatus", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def process_getRecordingServerReport(self, seqid, iprot, oprot):
    args = getRecordingServerReport_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = getRecordingServerReport_result()
    result.success = self._handler.getRecordingServerReport(args.deviceId)
    oprot.writeMessageBegin("getRecordingServerReport", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES

class getServerID_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerID_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getServerID_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getServerID_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setGlobalConfiguration_args:
  """
  Attributes:
   - configurations
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'configurations', None, None, ), # 1
  )

  def __init__(self, configurations=None,):
    self.configurations = configurations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.configurations = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setGlobalConfiguration_args')
    if self.configurations is not None:
      oprot.writeFieldBegin('configurations', TType.STRING, 1)
      oprot.writeString(self.configurations)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setGlobalConfiguration_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setGlobalConfiguration_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setDeviceConfiguration_args:
  """
  Attributes:
   - deviceId
   - channel
   - configurations
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'configurations', None, None, ), # 3
  )

  def __init__(self, deviceId=None, channel=None, configurations=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.configurations = configurations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.configurations = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setDeviceConfiguration_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.configurations is not None:
      oprot.writeFieldBegin('configurations', TType.STRING, 3)
      oprot.writeString(self.configurations)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setDeviceConfiguration_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setDeviceConfiguration_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setDeviceSnapshot_args:
  """
  Attributes:
   - deviceId
   - channel
   - snapshot
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'snapshot', None, None, ), # 3
  )

  def __init__(self, deviceId=None, channel=None, snapshot=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.snapshot = snapshot

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.snapshot = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setDeviceSnapshot_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.snapshot is not None:
      oprot.writeFieldBegin('snapshot', TType.STRING, 3)
      oprot.writeString(self.snapshot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class setDeviceSnapshot_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('setDeviceSnapshot_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startRecordingTask_args:
  """
  Attributes:
   - deviceId
   - channel
   - mediaType
   - streamProfile
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'mediaType', None, None, ), # 3
    (4, TType.STRING, 'streamProfile', None, None, ), # 4
  )

  def __init__(self, deviceId=None, channel=None, mediaType=None, streamProfile=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.mediaType = mediaType
    self.streamProfile = streamProfile

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.streamProfile = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startRecordingTask_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 3)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    if self.streamProfile is not None:
      oprot.writeFieldBegin('streamProfile', TType.STRING, 4)
      oprot.writeString(self.streamProfile)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startRecordingTask_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startRecordingTask_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopRecordingTask_args:
  """
  Attributes:
   - deviceId
   - channel
   - mediaType
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'mediaType', None, None, ), # 3
  )

  def __init__(self, deviceId=None, channel=None, mediaType=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.mediaType = mediaType

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopRecordingTask_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 3)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopRecordingTask_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopRecordingTask_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminateRecordingTask_args:
  """
  Attributes:
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
  )

  def __init__(self, deviceId=None,):
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminateRecordingTask_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class terminateRecordingTask_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('terminateRecordingTask_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecordingDetails_args:
  """
  Attributes:
   - deviceId
   - channel
   - deviceKey
   - mediaType
   - beginTime
   - endTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'deviceKey', None, None, ), # 3
    (4, TType.STRING, 'mediaType', None, None, ), # 4
    (5, TType.STRING, 'beginTime', None, None, ), # 5
    (6, TType.STRING, 'endTime', None, None, ), # 6
  )

  def __init__(self, deviceId=None, channel=None, deviceKey=None, mediaType=None, beginTime=None, endTime=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.deviceKey = deviceKey
    self.mediaType = mediaType
    self.beginTime = beginTime
    self.endTime = endTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.deviceKey = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.beginTime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.endTime = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecordingDetails_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.deviceKey is not None:
      oprot.writeFieldBegin('deviceKey', TType.STRING, 3)
      oprot.writeString(self.deviceKey)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 4)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    if self.beginTime is not None:
      oprot.writeFieldBegin('beginTime', TType.STRING, 5)
      oprot.writeString(self.beginTime)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.STRING, 6)
      oprot.writeString(self.endTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecordingDetails_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(CommStructures.ttypes.StreamFileDetails, CommStructures.ttypes.StreamFileDetails.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = CommStructures.ttypes.StreamFileDetails()
            _elem5.read(iprot)
            self.success.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecordingDetails_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter6 in self.success:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class triggerEventRecording_args:
  """
  Attributes:
   - deviceId
   - channel
   - mediaType
   - eventId
   - duration
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'mediaType', None, None, ), # 3
    (4, TType.STRING, 'eventId', None, None, ), # 4
    (5, TType.I32, 'duration', None, None, ), # 5
  )

  def __init__(self, deviceId=None, channel=None, mediaType=None, eventId=None, duration=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.mediaType = mediaType
    self.eventId = eventId
    self.duration = duration

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.eventId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.duration = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('triggerEventRecording_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 3)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.STRING, 4)
      oprot.writeString(self.eventId)
      oprot.writeFieldEnd()
    if self.duration is not None:
      oprot.writeFieldBegin('duration', TType.I32, 5)
      oprot.writeI32(self.duration)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class triggerEventRecording_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('triggerEventRecording_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEventRecording_args:
  """
  Attributes:
   - deviceId
   - channel
   - mediaType
   - eventId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'mediaType', None, None, ), # 3
    (4, TType.STRING, 'eventId', None, None, ), # 4
  )

  def __init__(self, deviceId=None, channel=None, mediaType=None, eventId=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.mediaType = mediaType
    self.eventId = eventId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.eventId = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEventRecording_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 3)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    if self.eventId is not None:
      oprot.writeFieldBegin('eventId', TType.STRING, 4)
      oprot.writeString(self.eventId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getEventRecording_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getEventRecording_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class triggerSpecifiedRecording_args:
  """
  Attributes:
   - deviceId
   - channel
   - mediaType
   - beginTime
   - endTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'mediaType', None, None, ), # 3
    (4, TType.STRING, 'beginTime', None, None, ), # 4
    (5, TType.STRING, 'endTime', None, None, ), # 5
  )

  def __init__(self, deviceId=None, channel=None, mediaType=None, beginTime=None, endTime=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.mediaType = mediaType
    self.beginTime = beginTime
    self.endTime = endTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.beginTime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.endTime = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('triggerSpecifiedRecording_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 3)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    if self.beginTime is not None:
      oprot.writeFieldBegin('beginTime', TType.STRING, 4)
      oprot.writeString(self.beginTime)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.STRING, 5)
      oprot.writeString(self.endTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class triggerSpecifiedRecording_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('triggerSpecifiedRecording_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSpecifiedRecording_args:
  """
  Attributes:
   - deviceId
   - channel
   - mediaType
   - beginTime
   - endTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'mediaType', None, None, ), # 3
    (4, TType.STRING, 'beginTime', None, None, ), # 4
    (5, TType.STRING, 'endTime', None, None, ), # 5
  )

  def __init__(self, deviceId=None, channel=None, mediaType=None, beginTime=None, endTime=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.mediaType = mediaType
    self.beginTime = beginTime
    self.endTime = endTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.beginTime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.endTime = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSpecifiedRecording_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 3)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    if self.beginTime is not None:
      oprot.writeFieldBegin('beginTime', TType.STRING, 4)
      oprot.writeString(self.beginTime)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.STRING, 5)
      oprot.writeString(self.endTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getSpecifiedRecording_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getSpecifiedRecording_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startRecordingUpload_args:
  """
  Attributes:
   - deviceId
   - channel
   - mediaType
   - beginTime
   - endTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'mediaType', None, None, ), # 3
    (4, TType.STRING, 'beginTime', None, None, ), # 4
    (5, TType.STRING, 'endTime', None, None, ), # 5
  )

  def __init__(self, deviceId=None, channel=None, mediaType=None, beginTime=None, endTime=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.mediaType = mediaType
    self.beginTime = beginTime
    self.endTime = endTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.beginTime = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.endTime = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startRecordingUpload_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 3)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    if self.beginTime is not None:
      oprot.writeFieldBegin('beginTime', TType.STRING, 4)
      oprot.writeString(self.beginTime)
      oprot.writeFieldEnd()
    if self.endTime is not None:
      oprot.writeFieldBegin('endTime', TType.STRING, 5)
      oprot.writeString(self.endTime)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class startRecordingUpload_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString();
            self.success.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('startRecordingUpload_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRING, len(self.success))
      for iter13 in self.success:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopRecordingUpload_args:
  """
  Attributes:
   - deviceId
   - channel
   - mediaType
   - fileTime
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'mediaType', None, None, ), # 3
    (4, TType.LIST, 'fileTime', (TType.STRING,None), None, ), # 4
  )

  def __init__(self, deviceId=None, channel=None, mediaType=None, fileTime=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.mediaType = mediaType
    self.fileTime = fileTime

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.fileTime = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = iprot.readString();
            self.fileTime.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopRecordingUpload_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 3)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    if self.fileTime is not None:
      oprot.writeFieldBegin('fileTime', TType.LIST, 4)
      oprot.writeListBegin(TType.STRING, len(self.fileTime))
      for iter20 in self.fileTime:
        oprot.writeString(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class stopRecordingUpload_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('stopRecordingUpload_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStreamStatus_args:
  """
  Attributes:
   - streamFileDetails
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'streamFileDetails', (TType.STRUCT,(CommStructures.ttypes.StreamFileDetails, CommStructures.ttypes.StreamFileDetails.thrift_spec)), None, ), # 1
  )

  def __init__(self, streamFileDetails=None,):
    self.streamFileDetails = streamFileDetails

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.streamFileDetails = []
          (_etype24, _size21) = iprot.readListBegin()
          for _i25 in xrange(_size21):
            _elem26 = CommStructures.ttypes.StreamFileDetails()
            _elem26.read(iprot)
            self.streamFileDetails.append(_elem26)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStreamStatus_args')
    if self.streamFileDetails is not None:
      oprot.writeFieldBegin('streamFileDetails', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.streamFileDetails))
      for iter27 in self.streamFileDetails:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStreamStatus_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(CommStructures.ttypes.StreamFileDetails, CommStructures.ttypes.StreamFileDetails.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = CommStructures.ttypes.StreamFileDetails()
            _elem33.read(iprot)
            self.success.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStreamStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter34 in self.success:
        iter34.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeMediaFile_args:
  """
  Attributes:
   - deviceId
   - channel
   - mediaType
   - mediaInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
    (2, TType.I32, 'channel', None, None, ), # 2
    (3, TType.STRING, 'mediaType', None, None, ), # 3
    (4, TType.STRING, 'mediaInfo', None, None, ), # 4
  )

  def __init__(self, deviceId=None, channel=None, mediaType=None, mediaInfo=None,):
    self.deviceId = deviceId
    self.channel = channel
    self.mediaType = mediaType
    self.mediaInfo = mediaInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.channel = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.mediaType = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.mediaInfo = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeMediaFile_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    if self.channel is not None:
      oprot.writeFieldBegin('channel', TType.I32, 2)
      oprot.writeI32(self.channel)
      oprot.writeFieldEnd()
    if self.mediaType is not None:
      oprot.writeFieldBegin('mediaType', TType.STRING, 3)
      oprot.writeString(self.mediaType)
      oprot.writeFieldEnd()
    if self.mediaInfo is not None:
      oprot.writeFieldBegin('mediaInfo', TType.STRING, 4)
      oprot.writeString(self.mediaInfo)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class removeMediaFile_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('removeMediaFile_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStorageStatus_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStorageStatus_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getStorageStatus_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT,(CommStructures.ttypes.StorageInfo, CommStructures.ttypes.StorageInfo.thrift_spec)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype38, _size35) = iprot.readListBegin()
          for _i39 in xrange(_size35):
            _elem40 = CommStructures.ttypes.StorageInfo()
            _elem40.read(iprot)
            self.success.append(_elem40)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getStorageStatus_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter41 in self.success:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecordingServerReport_args:
  """
  Attributes:
   - deviceId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'deviceId', None, None, ), # 1
  )

  def __init__(self, deviceId=None,):
    self.deviceId = deviceId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.deviceId = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecordingServerReport_args')
    if self.deviceId is not None:
      oprot.writeFieldBegin('deviceId', TType.I64, 1)
      oprot.writeI64(self.deviceId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class getRecordingServerReport_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('getRecordingServerReport_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
